#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Import Python Modules
import platform
import os
import sys
import datetime
import re
import xml.etree.ElementTree
import plistlib
import webbrowser
import requests
import keyring

# Import Tkinter GUI functions
import tkinter as tk
import tkinter.ttk as ttk
import tkinter.font as tkfont
import tkinter.messagebox as tkmessagebox
import tkinter.filedialog as tkfiledialog

# Import Matplotlib graph plotting functions
import matplotlib
matplotlib.use('TkAgg')
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# Import program data and modules
import data
import ofcom

# Define location of plist file
if platform.system() == 'Darwin':
	plistName = os.path.expanduser('~/Library/Preferences/com.stevebunting.rflibrary.plist')
else:
	plistName = '{}\My Documents\rflibrary.plist'.format(os.path.expanduser('~'))

# Helper function to set dateFormat
def set_date_format():
    if data.dateFormats.get(plist['defaultDateFormat']):
        return data.dateFormats.get(plist['defaultDateFormat'])
    else:
        return data.dateFormats.get(defaultDateFormat)
        
# Helper function to format directory
def dir_format(display_location, max_length):
    display_location = display_location.replace(os.path.expanduser('~'), '~', 1)
    while len(display_location) > max_length:
        display_location = '...{}{}'.format(data.slash, display_location.split(data.slash, 2)[2])
    return display_location

# Load settings plist if it exists yet
settingsExists = True
if not os.path.isfile(plistName):
    settingsExists = False
    fp = open(plistName, 'wb')
    fp.close()
    os.chmod(plistName, 0o600)
    plist = dict()
else:
    with open(plistName, 'rb') as fp:
        plist = plistlib.load(fp)

# Check for preferences and add default if not there
vars = ['ofcomAccountName', 'ofcomUserName', 'forename', 'surname', 'dirStructure', 'fileStructure', 'defaultOfcomInclude', 'defaultDateFormat', 'lowFreqLimit', 'highFreqLimit', 'defaultVenue', 'defaultTown', 'defaultCountry', 'defaultCopy', 'defaultDelete', 'defaultSourceLocation']
defaults = ['', '', '', '', '%c{}%t %v{}%y'.format(data.slash, data.slash), '%t %v-%c %y-%d-%m %i %n-%f', False, 'yyyy-dd-mm', 0, 0, 'Venue', 'Town', 'United Kingdom', True, False, os.path.expanduser('~')]
for var, default in zip(vars, defaults):
    if not plist.get(var):
        plist[var] = default
if not plist.get('defaultLibraryLocation'):
    if platform.system() == 'Darwin':
        plist['defaultLibraryLocation'] = os.path.expanduser('~/Documents/Scans')
    elif platform.system() == 'Windows':
        plist['defaultLibraryLocation'] = os.path.expanduser('~\My Documents\Scans')
    else:
        plist['defaultLibraryLocation'] = os.path.expanduser('/')

with open(plistName, 'wb') as fp:
    plistlib.dump(plist, fp)

dateFormat = set_date_format()

################################################################################
##########                      TOOLTIP OBJECT                        ##########
################################################################################

# SOURCE: https://stackoverflow.com/questions/3221956/what-is-the-simplest-way-to-make-tooltips-in-tkinter

class CreateToolTip(object):
    
    def __init__(self, widget, text='widget info'):
        self.waittime = 500     #miliseconds
        self.wraplength = 250   #pixels
        self.widget = widget
        self.text = text
        self.widget.bind('<Enter>', self.enter)
        self.widget.bind('<Leave>', self.leave)
        self.widget.bind('<ButtonPress>', self.leave)
        self.id = None
        self.tw = None

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.widget.after_cancel(id)

    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox('insert')
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        self.tw = tk.Toplevel(self.widget)

        # Leaves only the label and removes the app window
        self.tw.overrideredirect(True)
        self.tw.wm_geometry('+%d+%d' % (x, y))
        label = ttk.Label(self.tw, text=self.text, justify='left',
                       background='#b0b0b0', relief='solid', borderwidth=1, padding=2, foreground='#4040ff',
                       wraplength = self.wraplength)
        label.pack(ipadx=1)
        self.tw.lift()
        
    def hidetip(self):
        tw = self.tw
        self.tw = None
        if tw:
            tw.destroy()

################################################################################
##########                        FILE OBJECT                         ##########
################################################################################

# Define Data class
class File():

    # Initialise class
    def __init__(self, name, tvCountry):
        self.fullfilename = name
        self.filename = os.path.basename(self.fullfilename)
        self.file, self.ext = os.path.splitext(self.filename)
        self.path = os.path.dirname(self.fullfilename)
        self.valid = True
        self.readFile()
        if self.valid:
            self.updateTVChannels(tvCountry)
            self.getNewFilename()
            self.ioRead()
        
    # Method to check validity and get file details
    def readFile(self):
        # Ensure file has valid extension
        if self.ext.lower() != '.csv' and self.ext.lower() != '.sdb2':
            self.valid = False
            return
        
        # Read first line of file
        self.frequencies = []
        self.fp = open(self.fullfilename, 'r', encoding='utf-8')
        firstLine = self.fp.readline().rstrip()
        self.fp.seek(0)
        
        # Identify type of scan file from first line and parse
        if firstLine[0:11] == 'Model Type:':
            self.parseCSVScan('TTi {}'.format(firstLine[12:-1]))
        elif firstLine[0:9] == 'Receiver;':
            self.parseWSMScan()
        elif firstLine[0:38] == '<?xml version="1.0" encoding="UTF-8"?>':
            self.parseShureScan()
        else:
            self.parseCSVScan('Generic')
        self.fp.close()
        if len(self.frequencies) == 0:
            self.valid = False
            return
        
        # Get file details
        self.startFrequency = min(freq[0] for freq in self.frequencies)
        self.stopFrequency = max(freq[0] for freq in self.frequencies)
        self.dataPoints = len(self.frequencies)
        self.resolution = ((self.stopFrequency - self.startFrequency)
                          / (self.dataPoints - 1))
    
    # Parse an XML scan created by Shure WWB6 and hardware
    def parseShureScan(self):
        tree = xml.etree.ElementTree.parse(self.fp)
        xmldoc = tree.getroot()
        model = xmldoc.attrib['model']
        if model == 'TODO' or model == '':
            self.model = 'Shure AXT600'
        else:
            self.model = 'Shure {} ({})'.format(model, xmldoc.attrib['band'])
        self.frequencies = []
        for freq, level in zip(xmldoc[0][0], xmldoc[0][1]):
            self.frequencies.append([float(freq.text) / 1000, float(level.text)])
        self.creationDate = datetime.datetime.fromtimestamp(
                            float(xmldoc[0][1].attrib['date_time']) / 1000)
            
    # Parse a CSV file
    def parseCSVScan(self, model):
        self.model = model
        for line in self.fp:
            splitLine = re.split('[\t,;]', line)
            try:
                freq = float(splitLine[0].strip())
                value = float(splitLine[1].strip())
                self.frequencies.append([freq, value])
            except ValueError:
                pass
        self.getCreationDate()
            
    # Parse a WSM file
    def parseWSMScan(self):
        self.model = 'Sennheiser WSM'
        wsmLowLimit = -99
        wsmHighLimit = -30
        wsmMultiplier = wsmLowLimit - wsmHighLimit # -69
        for line in self.fp:
            splitLine = re.split('[    ,; ]', line)
            try:
                freq = float(splitLine[0]) / 1000
                value = wsmLowLimit - (float(splitLine[2]) * 0.0065 * wsmMultiplier)
                # -34.2 = -99 - (9988 * ? * -69)
                # -64.8 / (9988 * -69) = 0,0065

                if freq > 1:
                    self.frequencies.append([freq, value])
            except (ValueError, IndexError):
                pass
        self.getCreationDate()
    
    # Method to return creation date from file
    def getCreationDate(self):
        self.creationDate = datetime.datetime.fromtimestamp(os.stat(self.fullfilename).st_birthtime)
    
    # Method to get TV channels
    def updateTVChannels(self, tvCountry):
        if tvCountry == 'United States of America':
            tvCountry = tvCountry
        else:
            tvCountry = 'UK'
        self.startTVChannel = None
        self.stopTVChannel = None
        for chan in data.TVChannels[tvCountry]:
            if self.startTVChannel == None:
                if (self.startFrequency >= float(chan[1]) and
                    self.startFrequency < float(chan[2])):
                    self.startTVChannel = chan[0]
            else:
                if (self.stopFrequency > float(chan[1]) and
                    self.stopFrequency <= float(chan[2])):
                    self.stopTVChannel = chan[0]
                    break
        
    # Method to get new filename based on BestAudio naming structure
    def getNewFilename(self):
        if 80 <= self.startFrequency <= 120:
            self.newFilename = 'FM'
        elif 54 <= self.startFrequency <= 88:
            self.newFilename = '{:02d}'.format(int(self.startFrequency - 42) // 6)
        elif 174 <= self.startFrequency <= 216:
            self.newFilename = '{:02d}'.format(int(self.startFrequency - 132) // 6)
        elif 470 <= self.startFrequency <= 890:
            self.newFilename = '{:02d}'.format(int(self.startFrequency - 386) // 6)
        elif 902 <= self.startFrequency <= 928:
            self.newFilename = '900'
        elif 944 <= self.startFrequency <= 952:
            self.newFilename = 'X1'
        elif 1920 <= self.startFrequency <= 1930:
            self.newFilename = 'DUSA'
        elif 1910 <= self.startFrequency <= 1930:
            self.newFilename = 'DSA'
        elif 1910 <= self.startFrequency <= 1920:
            self.newFilename = 'DBRA'
        elif 1893 <= self.startFrequency <= 1906:
            self.newFilename = 'DJAP'
        elif 1880 <= self.startFrequency <= 1900:
            self.newFilename = 'DEURAU'
        else:
            self.newFilename = '{:.0f}MHz'.format(self.startFrequency)
        self.newFilename = '{}.csv'.format(self.newFilename)
    
    # Method to guess whether scan is inside or outside
    def ioRead(self):
        self.io = 0
        lowercaseFilename = self.file.lower()
        if 'in' in lowercaseFilename:
            self.io = 1
        elif 'out' in lowercaseFilename:
            self.io = -1

################################################################################
##########                  SETTINGS WINDOW OBJECT                    ##########
################################################################################

class SettingsWindow():

    # Initialise class
    def __init__(self):

        # Variables
        self.passwordChanged = False

        self.settingsWindow = tk.Toplevel(takefocus=True)
        self.bringtofront()
        
        self.settingsWindow.title('Settings')
        self.settingsWindow.resizable(width=False, height=False)
        self.settingsWindow.geometry('509x556')
        
        self._createSettingsFrames()
        self._createSettingsWidgets()
    
    # Create settings frames
    def _createSettingsFrames(self):
        self.settingsMasterFrame = ttk.Frame(self.settingsWindow)
        self.settingsMasterFrame.grid(padx=0, pady=0, sticky='NWSE')
        
        self.outputPreferences = ttk.LabelFrame(
            self.settingsMasterFrame, text='Output Preferences')
        self.outputPreferences.grid(padx=16, pady=16, sticky='NWSE')
        
        self.personalData = ttk.LabelFrame(
            self.settingsMasterFrame, text='Personal Data')
        self.personalData.grid(padx=16, pady=16, sticky='NWSE')
        
        self.ofcomLogin = ttk.LabelFrame(
            self.settingsMasterFrame, text='OFCOM Login Data')
        self.ofcomLogin.grid(padx=16, pady=16, sticky='NWSE')
        
        self.settingsButtonsFrame = ttk.Frame(self.settingsMasterFrame)
        self.settingsButtonsFrame.grid(
            padx=16, pady=16, columnspan=2, sticky='NWSE')
    
    # Create settings widgets
    def _createSettingsWidgets(self):
    
        # Initialise Tk variables
        self.sourceFolderDisplay = tk.StringVar()
        self.scansFolderDisplay = tk.StringVar()
        self.dirStructure = tk.StringVar()
        self.fileStructure = tk.StringVar()
        self.lowFreqLimit = tk.StringVar()
        self.highFreqLimit = tk.StringVar()
        self.defaultDateFormat = tk.StringVar()
        self.forename = tk.StringVar()
        self.surname = tk.StringVar()
        self.ofcomAccountName = tk.StringVar()
        self.ofcomUserName = tk.StringVar()
        self.ofcomPassword = tk.StringVar()

        # Set Variables
        vars = [plist['dirStructure'], plist['fileStructure'],
                dir_format(plist['defaultSourceLocation'], 50), dir_format(plist['defaultLibraryLocation'], 50),
                plist['lowFreqLimit'], plist['highFreqLimit'],
                plist['defaultDateFormat'], plist['forename'], plist['surname'],
                plist['ofcomAccountName'], plist['ofcomUserName'], ' ' * 8]
        fields = [self.dirStructure, self.fileStructure, self.sourceFolderDisplay,
                  self.scansFolderDisplay, self.lowFreqLimit, self.highFreqLimit,
                  self.defaultDateFormat, self.forename, self.surname,
                  self.ofcomAccountName, self.ofcomUserName, self.ofcomPassword]
        for field, var in zip(fields, vars):
            field.set(var)
        
        # Scans Folder
        ttk.Label(self.outputPreferences, text='Scans Folder', width='16').grid(column=0, row=0, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.scansFolderLabel = ttk.Label(self.outputPreferences, textvariable=self.scansFolderDisplay, width='36')
        self.scansFolderLabel.grid(column=1, row=0, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.scansFolderLabel, 'Scan library base folder')
        self.changeBaseFolderButton = ttk.Button(self.outputPreferences, text='Change Folder', command=self._changeBaseFolder)
        self.changeBaseFolderButton.grid(column=1, row=1)
        
        # Directory Structure
        ttk.Label(self.outputPreferences, text='Directory Structure', width='16').grid(column=0, row=2, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.dirStructureEntry = ttk.Entry(self.outputPreferences, textvariable=self.dirStructure, width='35')
        self.dirStructureEntry.grid(column=1, row=2, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.dirStructureEntry, 'Default library directory structure (see docs for more details')
        
        # Filename Structure
        ttk.Label(self.outputPreferences, text='Filename Structure', width='16').grid(column=0, row=3, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.fileStructureEntry = ttk.Entry(self.outputPreferences, textvariable=self.fileStructure, width='35')
        self.fileStructureEntry.grid(column=1, row=3, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.fileStructureEntry, 'Default library filename structure (see docs for more details')
        
        # Date Format
        ttk.Label(self.outputPreferences, text='Date Format', width='16').grid(column=0, row=4, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.dateFormatBox = ttk.Combobox(self.outputPreferences, textvariable=self.defaultDateFormat)
        self.dateFormatBox['values'] = [key for key in data.dateFormats]
        self.dateFormatBox.grid(column=1, row=4, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.dateFormatBox, 'Preferred date format')
        
        # Low Frequency Limit
        ttk.Label(self.outputPreferences, text='Low Frequency Limit', width='16').grid(column=0, row=5, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.lowFreqLimitEntry = ttk.Entry(self.outputPreferences, textvariable=self.lowFreqLimit)
        self.lowFreqLimitEntry.grid(column=1, row=5)
        CreateToolTip(self.lowFreqLimitEntry, 'Low frequency limit for the output file (set to 0 for no limit)')
        
        # High Frequency Limit
        ttk.Label(self.outputPreferences, text='High Frequency Limit', width='16').grid(column=0, row=6, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.highFreqLimitEntry = ttk.Entry(self.outputPreferences, textvariable=self.highFreqLimit)
        self.highFreqLimitEntry.grid(column=1, row=6)
        CreateToolTip(self.highFreqLimitEntry, 'High frequency limit for the output file (set to 0 for no limit)')
        
        # Forename Entry
        ttk.Label(self.personalData, text='Forename', width='16').grid(column=0, row=0, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.forenameEntry = ttk.Entry(self.personalData, textvariable=self.forename)
        self.forenameEntry.grid(column=1, row=0)
        CreateToolTip(self.forenameEntry, 'Your forename')
        
        # Surname Entry
        ttk.Label(self.personalData, text='Surname', width='16').grid(column=0, row=1, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.surnameEntry = ttk.Entry(self.personalData, textvariable=self.surname)
        self.surnameEntry.grid(column=1, row=1)
        CreateToolTip(self.surnameEntry, 'Your surname')
        
        # OFCOM Account Name Entry
        ttk.Label(self.ofcomLogin, text='Account Name', width='16').grid(column=0, row=0, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.ofcomAccountNameEntry = ttk.Entry(self.ofcomLogin, textvariable=self.ofcomAccountName)
        self.ofcomAccountNameEntry.grid(column=1, row=0)
        CreateToolTip(self.ofcomAccountNameEntry, 'Your OFCOM Account Name')
        
        # OFCOM User Name Entry
        ttk.Label(self.ofcomLogin, text='User Name', width='16').grid(column=0, row=1, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.ofcomUsernameEntry = ttk.Entry(self.ofcomLogin, textvariable=self.ofcomUserName)
        self.ofcomUsernameEntry.grid(column=1, row=1)
        CreateToolTip(self.ofcomUsernameEntry, 'Your OFCOM User Name')
        
        # OFCOM Password Entry
        ttk.Label(self.ofcomLogin, text='Password', width='16').grid(column=0, row=2, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.ofcomPasswordEntry = ttk.Entry(self.ofcomLogin, show="\u2022", textvariable=self.ofcomPassword)
        self.ofcomPasswordEntry.grid(column=1, row=2)
        CreateToolTip(self.ofcomPasswordEntry, 'Your OFCOM Password')
        
        # Buttons
        self.saveSettingsButton = ttk.Button(self.settingsButtonsFrame, text='Save', command=self._saveSettings)
        self.saveSettingsButton.grid(column=0, row=0)
        CreateToolTip(self.saveSettingsButton, 'Save changes')
        self.cancelSettingsButton = ttk.Button(self.settingsButtonsFrame, text='Cancel', command=self._closeSettings)
        self.cancelSettingsButton.grid(column=1, row=0)
        CreateToolTip(self.cancelSettingsButton, 'Discard changes')
        
        #Bindings
        self.settingsWindow.bind_all('<Return>', self._saveSettings)
        self.settingsWindow.bind_all('<Escape>', self._closeSettings)
        self.ofcomPasswordEntry.bind('<KeyRelease>', self._passwordEntry)
        
        # Add padding to all entry boxes
        for widget in [self.changeBaseFolderButton, self.forenameEntry, self.surnameEntry, self.lowFreqLimitEntry, self.highFreqLimitEntry, self.saveSettingsButton, self.cancelSettingsButton]:
            widget.grid(sticky='W', padx=data.padx_default, pady=data.pady_default)
    
    # Method to detect if password is amended
    def _passwordEntry(self, event=None):
        if not self.passwordChanged:
            self.passwordChanged = True
            self.ofcomPassword.set(self.ofcomPassword.get().lstrip())

    # Method to select default source folder
    def _changeSourceFolder(self):
        dir = tkfiledialog.askdirectory(parent=self.settingsMasterFrame, title='Select Source Folder', initialdir=plist['defaultSourceLocation'])
        if dir != '':
            plist['defaultSourceLocation'] = dir
            self.sourceFolderDisplay.set(dir_format(plist['defaultSourceLocation'], 50))
            
    # Method to select scans base folder
    def _changeBaseFolder(self):
        dir = tkfiledialog.askdirectory(parent=self.settingsMasterFrame, title='Select Scan Folder', initialdir=plist['defaultLibraryLocation'])
        if dir != '':
            plist['defaultLibraryLocation'] = dir
            self.scansFolderDisplay.set(dir_format(plist['defaultLibraryLocation'], 50))
    
    # Method to save settings and close window    
    def _saveSettings(self, event=None):
        
        # Ensure limits are good ints else revert to default
        defaults = [plist['lowFreqLimit'], plist['highFreqLimit']]
        for var, default in zip([self.lowFreqLimit, self.highFreqLimit], defaults):
            if var.get() == '':
                var.set(0)
            else:
                try:
                    int(var.get())
                except ValueError:
                    var.set(default)
            if int(var.get()) < 0:
                var.set(0)
        if int(self.lowFreqLimit.get()) > int(self.highFreqLimit.get()):
            self.lowFreqLimit.set(self.highFreqLimit.get())
        elif int(self.highFreqLimit.get()) < int(self.lowFreqLimit.get()):
            self.highFreqLimit.set(self.lowFreqLimit.get())

        plist['ofcomAccountName'] = self.ofcomAccountName.get()
        plist['ofcomUserName'] = self.ofcomUserName.get()
        plist['forename'] = self.forename.get()
        plist['surname'] = self.surname.get()
        plist['dirStructure'] = self.dirStructure.get().strip('/')
        plist['fileStructure'] = self.fileStructure.get()
        plist['defaultDateFormat'] = self.defaultDateFormat.get()
        plist['lowFreqLimit'] = int(self.lowFreqLimit.get())
        plist['highFreqLimit'] = int(self.highFreqLimit.get())
        with open(plistName, 'wb') as fp:
            plistlib.dump(plist, fp)
        if self.passwordChanged:
            keyring.set_password(data.title, self.ofcomAccountName.get(), self.ofcomPassword.get())
        self._closeSettings()
    
    # Method to close settings window
    def _closeSettings(self, event=None):
        self.settingsWindow.quit()
        self.settingsWindow.destroy()
    
    # Method to bring settings window to front
    def bringtofront(self):
        self.settingsWindow.lift()
    
################################################################################
##########                         GUI OBJECT                         ##########
################################################################################

class GUI():

    # Initialise class
    def __init__(self):
 
        # Variables
        self.files = []
        self.fileListboxSelection = None
        self.subdirectory = True
        self.settingsWindowOpen = False
        self.ioGuess = 0
        self.ioFixed = False
        self.customMasterFilename = False
        self.customSubdirectory = False
        self.pmseLookupVenues = [[], []]
        
        # Create instance
        self.window = tk.Tk()
        
        # Configure main window
        self.window.resizable(width=False, height=False)
        self.window.geometry('840x698')
        self.window.title(data.title)
        self.window.config(background='lightGrey')
        self.window.iconbitmap('logo.ico')
        
        # Configure OS X Application menu
        if platform.system() == 'Darwin':
            self.window.createcommand('tkAboutDialog', self._about)
            self.window.createcommand('::tk::mac::ShowPreferences', self._settings)
        
        # Build window
        self._createStyles()
        self._createFrames()
        self._createMenu()
        self._createWidgets()
        
        # Open settings if settings uninitialised
        if not settingsExists:
            self._settings()
    
    # Create styles for GUI
    def _createStyles(self):
        self.fontSize = 13
        default_font = tkfont.nametofont('TkDefaultFont')
        default_font.configure(size=self.fontSize)
        self.sdFocusColor = 'red'
        self.sdNoFocusColor = 'darkgrey'
        self.baseBackground = '#dcdad5'
     
        self.guiStyle = ttk.Style()
        self.guiStyle.theme_use('clam')
        self.guiStyle.map('TCombobox', fieldbackground=[('readonly', 'white')])
        self.guiStyle.configure('TLabelframe.Label', font='Arial 16')
        self.guiStyle.map('TRadiobutton', background=[('hover', self.baseBackground)])
        self.guiStyle.map('TCheckbutton', background=[('hover', self.baseBackground)])
        
    # Create GUI frames
    def _createFrames(self):
        self.masterFrame = ttk.Frame(self.window)
        self.masterFrame.grid(padx=0, pady=0, sticky='NWE')
     
        self.leftContainer = ttk.Frame(self.masterFrame)
        self.leftContainer.grid(column=0, row=0, padx=0, pady=0, stick='NWE')

        self.rightContainer = ttk.Frame(self.masterFrame)
        self.rightContainer.grid(column=1, row=0, padx=0, pady=0, sticky='NWE')
     
        self.inputFrame = ttk.LabelFrame(self.leftContainer, text='Source Data')
        self.inputFrame.grid(column=0, row=0, padx=10, pady=10, sticky='NWE')
                          
        self.infoFrame = ttk.LabelFrame(self.leftContainer, text='Venue Information')
        self.infoFrame.grid(column=0, row=1, padx=8, pady=8, sticky='NWE')

        self.previewFrame = ttk.LabelFrame(self.rightContainer, text='Source Preview')
        self.previewFrame.grid(column=0, row=0, columnspan=2, padx=8, pady=8, sticky='NWE')
        CreateToolTip(self.previewFrame, 'Selected scan preview')
                          
        self.ofcomFrame = ttk.LabelFrame(self.rightContainer, text='OFCOM')
        self.ofcomFrame.grid(column=0, row=1, padx=8, pady=8, sticky='NWE')
     
        self.outputFrame = ttk.LabelFrame(self.masterFrame, text='Output Data')
        self.outputFrame.grid(column=0, row=1, columnspan=3, padx=8, pady=8, sticky='NWE')
        
        # Initialise graph window
        self.fig = matplotlib.figure.Figure(figsize=(3.2, 2.65), dpi=100, facecolor='white')
        self.ax = self.fig.add_subplot(111)
        self.ax.set_position([0.15, 0.1, 0.81, 0.81])
        self.canvas = FigureCanvasTkAgg(self.fig, self.previewFrame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self._clearPreview()
    
    # Create GUI menu
    def _createMenu(self):
        self.menuBar = tk.Menu(self.window)
        
        # File Menu
        self.fileMenu = tk.Menu(self.menuBar, tearoff=False)
        self.fileMenu.add_command(label='Add Files', accelerator='Command-a', command=self._addFiles)
        self.fileMenu.add_command(label='Add Directory', accelerator='Command-Shift-a', command=self._addDirectory)
        self.fileMenu.add_separator()
        self.fileMenu.add_command(label='Set Date', accelerator='Command-d', command=self._useDate) 
        self.fileMenu.add_command(label='Set Destination', accelerator='Command-Shift-d', command=self._customDestination) 
        self.fileMenu.add_command(label='Create File', accelerator='Command-Return', command=self._createFile)
        self.menuBar.add_cascade(label='File', menu=self.fileMenu)
        
        # Edit Menu
        self.editMenu = tk.Menu(self.menuBar, tearoff=False)
        self.editMenu.add_command(label='Remove File', accelerator='BackSpace', command=self._removeFile)
        self.editMenu.add_command(label='Clear Files', accelerator='Command-BackSpace', command=self._clearFiles)
        self.menuBar.add_cascade(label='Edit', menu=self.editMenu)

        # Help Menu
        self.helpMenu = tk.Menu(self.menuBar, tearoff=False)
        self.helpMenu.add_command(label='Documentation', command=self._openHTTP)
        self.menuBar.add_cascade(label='Help', menu=self.helpMenu)
     
        self.window.config(menu=self.menuBar)
        
        self.window.bind_all('<Command-a>', self._addFiles)
        self.window.bind_all('<Command-Shift-a>', self._addDirectory)
        self.window.bind_all('<Command-Shift-d>', self._customDestination)
    
    # Create GUI widgets
    def _createWidgets(self):
    
        # Initialise tkinter variables
        self.numFiles = tk.StringVar()
        self.venue = tk.StringVar()
        self.town = tk.StringVar()
        self.country = tk.StringVar()
        self.scanDate = tk.StringVar()
        self.io = tk.StringVar()
        self.ofcomSearch = tk.StringVar()
        self.ofcomVenue = tk.StringVar()
        self.includeOfcomData = tk.BooleanVar()
        self.scanOutputLocationDisplay = tk.StringVar()
        self.targetSubdirectory = tk.StringVar()
        self.defaultOutputLocation = tk.BooleanVar()
        self.scanMasterFilename = tk.StringVar()
        self.defaultMasterFilename = tk.BooleanVar()
        self.copySourceFiles = tk.BooleanVar()
        self.deleteSourceFiles = tk.BooleanVar()
        
        # Set default values
        fields = [self.venue, self.town, self.country, self.copySourceFiles, self.deleteSourceFiles, self.includeOfcomData]
        vars = [plist['defaultVenue'], plist['defaultTown'], plist['defaultCountry'], plist['defaultCopy'], plist['defaultDelete'], plist['defaultOfcomInclude']]
        for field, var in zip(fields, vars):
            field.set(var)
        self.ofcomVenueList = ['No venues found...']
        
        # File List
        ttk.Label(self.inputFrame, text='File List').grid(column=0, row=0, sticky='W')
        self.fileListbox = tk.Listbox(self.inputFrame, height=8, width=20)
        self.fileListbox.bind('<<ListboxSelect>>', self._selectFileItem)
        self.fileListbox.grid(column=0, row=1, padx=data.padx_default, pady=data.pady_default)
        
        # Data List
        ttk.Label(self.inputFrame, text='Selected File Information').grid(column=1, row=0, sticky='W')
        self.dataListbox = tk.Listbox(self.inputFrame, height=8, width=30)
        self.dataListbox.grid(column=1, row=1, padx=data.padx_default, pady=data.pady_default)
        self.dataListbox.configure(background='lightGrey')
     
        # File List Edit Buttons
        self.fileListEditFrame = ttk.Frame(self.inputFrame)
        self.fileListEditFrame.grid(column=0, row=2, columnspan=2, sticky='W')
        self.addFilesButton = ttk.Button(self.fileListEditFrame, text='Add Files', command=self._addFiles)
        self.addFilesButton.grid(column=0, row=0, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.addFilesButton, 'Add files to file list (⌘A)')
        self.removeFileButton = ttk.Button(self.fileListEditFrame, text='Remove File', command=self._removeFile)
        self.removeFileButton.grid(column=1, row=0, sticky='W', padx=data.padx_default, pady=0)
        CreateToolTip(self.removeFileButton, 'Remove selected file from file list (⌫)')
        self.clearFilesButton = ttk.Button(self.fileListEditFrame, text='Clear Files', command=self._clearFiles)
        self.clearFilesButton.grid(column=2, row=0, sticky='W', padx=data.padx_default, pady=0)
        CreateToolTip(self.clearFilesButton, 'Remove all files from file list (⌘⌫)')
        self.useDateButton = ttk.Button(self.fileListEditFrame, text='Set Date', command=self._useDate)
        self.useDateButton.grid(column=3, row=0, sticky='W', padx=data.padx_default, pady=0)
        CreateToolTip(self.useDateButton, 'Use currently selected file\'s creation date for scan date (⌘D)')
     
        # File Info status
        self.fileStatus = ttk.Label(self.inputFrame, textvariable=self.numFiles)
        self.fileStatus.grid(column=0, row=3, sticky='W', padx=data.padx_default, pady=data.pady_default)
     
        # Source Venue Data
        ttk.Label(self.infoFrame, text='Venue', width=12).grid(column=0, row=0, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.venueEntry = ttk.Entry(self.infoFrame, textvariable=self.venue, width=20, font='TkDefaultFont {}'.format(self.fontSize))
        self.venueEntry.grid(column=1, row=0)
        CreateToolTip(self.venueEntry, 'Scan location name')

        # Source Town Data
        ttk.Label(self.infoFrame, text='Town', width=12).grid(column=0, row=1, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.townEntry = ttk.Entry(self.infoFrame, textvariable=self.town, width=20, font='TkDefaultFont {}'.format(self.fontSize))
        self.townEntry.grid(column=1, row=1)
        CreateToolTip(self.townEntry, 'Scan location town/city')

        # Source Country Data
        ttk.Label(self.infoFrame, text='Country', width=12).grid(column=0, row=2, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.countryBox = ttk.Combobox(self.infoFrame, textvariable=self.country, width=20, font='TkDefaultFont {}'.format(self.fontSize))
        self.countryBox['values'] = data.countries
        self.countryBox.grid(column=1, row=2, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.countryBox.bind('<<ComboboxSelected>>', self._refresh)
        CreateToolTip(self.countryBox, 'Scan location country')
     
        # Source Scan Date
        ttk.Label(self.infoFrame, text='Scan Date', width=12).grid(column=0, row=3, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.dateEntry = ttk.Entry(self.infoFrame, textvariable=self.scanDate, width=20, font='TkDefaultFont {}'.format(self.fontSize))
        self.dateEntry.grid(column=1, row=3)
        self.dateEntry.config(state='readonly')
        CreateToolTip(self.dateEntry, 'Date scan was taken')
     
        # Inside / Outside
        ttk.Label(self.infoFrame, text='Inside/Outside', width=12).grid(column=0, row=4, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.ioBox = ttk.Combobox(self.infoFrame, textvariable=self.io, width=20, state='readonly', font='TkDefaultFont {}'.format(self.fontSize))
        self.ioBox['values'] = ['Inside', 'Outside']
        self.ioBox.grid(column=1, row=4)
        self.ioBox.current(0)
        self.ioBox.bind('<<ComboboxSelected>>', self._ioBoxEdit)
        CreateToolTip(self.ioBox, 'Was the scan taken inside or outside?')
        
        # OFCOM Search Bar
        ttk.Label(self.rightContainer, text='OFCOM Search', width=12).grid(column=0, row=1, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.ofcomSearchEntry = ttk.Entry(self.rightContainer, textvariable=self.ofcomSearch, width=20, font='TkDefaultFont {}'.format(self.fontSize))
        self.ofcomSearchEntry.grid(column=1, row=1, sticky='NW')
        CreateToolTip(self.ofcomSearchEntry, 'OFCOM Database Search')

        # OFCOM Search Buton
        self.ofcomSearchButton = ttk.Button(self.rightContainer, text='OFCOM Search', command=self._ofcomSearch)
        self.ofcomSearchButton.grid(column=1, row=2, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.ofcomSearchButton, 'Search OFCOM database (⌘S)')
        
        # OFCOM Venue List
        ttk.Label(self.rightContainer, text='Venue Check', width=12).grid(column=0, row=3, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.ofcomBox = ttk.Combobox(self.rightContainer, textvariable=self.ofcomVenue, width=20, state='readonly', font='TkDefaultFont {}'.format(self.fontSize))
        self.ofcomBox['values'] = self.ofcomVenueList
        self.ofcomBox.grid(column=1, row=3, sticky='NW')
        self.ofcomBox.current(0)
        self.ofcomBox.config(state='disabled')
        CreateToolTip(self.ofcomBox, 'Select the correct venue from the list')

        # OFCOM Include Button
        self.includeOfcomDataCheck = ttk.Checkbutton(self.rightContainer, text='Include Exclusion Files', variable=self.includeOfcomData)
        self.includeOfcomDataCheck.grid(column=1, row=4, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.includeOfcomDataCheck, 'Include OFCOM Exclusion Data')
        
        # Output Location
        self.targetSubdirectory.set(self.io.get())
        ttk.Label(self.outputFrame, text='Destination', width=12).grid(column=0, row=0, columnspan = 2, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.targetDirectory = ttk.Label(self.outputFrame, textvariable=self.scanOutputLocationDisplay, width=77)
        self.targetDirectory.grid(column=1, row=0, sticky='W')
        CreateToolTip(self.targetDirectory, 'Output scan folder')
        
        # Subdirectory
        ttk.Label(self.outputFrame, text='Subdirectory', width=12).grid(column=0, row=1, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.targetSubdirectoryEntry = ttk.Entry(self.outputFrame, textvariable=self.targetSubdirectory, width=20, font='TkDefaultFont {}'.format(self.fontSize), style='Subdirectory.TEntry')
        self.targetSubdirectoryEntry.grid(column=1, row=1, sticky='W', padx=0, pady=data.pady_default)
        self.targetSubdirectoryEntry.bind('<KeyRelease>', self._customSubDirectory)
        CreateToolTip(self.targetSubdirectoryEntry, 'Optional subdirectory')
     
        # Output Master Filename
        ttk.Label(self.outputFrame, text='Master Filename', width=12).grid(column=0, row=2, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.scanMasterFilenameEntry = ttk.Entry(self.outputFrame, textvariable=self.scanMasterFilename, font='TkDefaultFont {}'.format(self.fontSize))
        self.scanMasterFilenameEntry.grid(column=1, row=2, sticky='W', padx=data.padx_default, pady=data.pady_default)
        self.scanMasterFilenameEntry.config(width=60)
        self.scanMasterFilenameEntry.bind('<KeyRelease>', self._customMasterFilename)
        CreateToolTip(self.scanMasterFilenameEntry, 'Master output filename')
        
        # Options
        ttk.Label(self.outputFrame, text='Options', width=12).grid(column=0, row=3, sticky='NW', padx=data.padx_default, pady=data.pady_default)
        self.defaultOutputLocation.set(1)
        self.defaultOutputCheck = ttk.Radiobutton(self.outputFrame, text='Standard Destination', variable=self.defaultOutputLocation, command=self._updateSubdirectory)
        self.defaultOutputCheck.grid(column=1, row=3, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.defaultOutputCheck, 'Check to use default library destination folder')
        self.defaultMasterFilename.set(1)
        self.defaultMasterFilenameCheck = ttk.Radiobutton(self.outputFrame, text='Standard Filename', variable=self.defaultMasterFilename, command=self._standardMasterFilename)
        self.defaultMasterFilenameCheck.grid(column=1, row=4, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.defaultMasterFilenameCheck, 'Check to use default filename')
        self.copySourceFilesCheck = ttk.Checkbutton(self.outputFrame, text='Duplicate Source Files', variable=self.copySourceFiles)
        self.copySourceFilesCheck.grid(column=1, row=5, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.copySourceFilesCheck, 'Duplicate source files in library')
        self.deleteSourceFilesCheck = ttk.Checkbutton(self.outputFrame, text='Delete Source Files', variable=self.deleteSourceFiles)
        self.deleteSourceFilesCheck.grid(column=1, row=6, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.deleteSourceFilesCheck, 'Delete source files on file creation')

        # Output Buttons
        self.outputButtons = ttk.Frame(self.outputFrame)
        self.outputButtons.grid(column=1, row=7, sticky='W')
        self.createFileButton = ttk.Button(self.outputButtons, text='Create File', command=self._createFile)
        self.createFileButton.grid(column=0, row=0, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.createFileButton, 'Create master file (⌘↵)')
        self.customOutputButton = ttk.Button(self.outputButtons, text='Set Destination', command=self._customDestination)
        self.customOutputButton.grid(column=1, row=0, sticky='W', padx=data.padx_default, pady=data.pady_default)
        CreateToolTip(self.customOutputButton, 'Set custom destination for output files (⌘⇧D)')
     
        # Add styling to all entry boxes
        for x in [self.venueEntry, self.townEntry, self.countryBox, self.dateEntry, self.ioBox]:
            x.grid(sticky='NW', padx=data.padx_default, pady=data.pady_default)
            x.bind('<KeyRelease>', self._getMasterFilename)
        
        # Key Bindings
        self.window.bind_all('<Command-Return>', self._createFile)
        self.window.bind_all('<Command-s>', self._ofcomSearch)
        self.fileListbox.bind('<Escape>', self._deselectFileListbox)
        self.fileListbox.bind('<BackSpace>', self._removeFile)
         
        # Initialise Lists
        self._printFiles()

################################################################################
##########                       GUI METHODS                          ##########
################################################################################
             
    # Method to update filelist
    def _printFiles(self, event=None):
        self.fileListbox.delete(0, tk.END)
        for file in self.files:
            self.fileListbox.insert(tk.END, file.filename)
        self._selectFileItem(event)
        self._updateFileStatus()
        self._getScanDate()
        self._getMasterFilename()

    # Method to select fileListbox item
    def _selectFileItem(self, event=None):
        if event:
            try:
                self.fileListboxSelection = int(event.widget.curselection()[0])
            except (AttributeError, IndexError):
                pass
        self.fileListbox.selection_clear(0, tk.END)
        if self.fileListboxSelection != None:
            self.fileListbox.select_set(self.fileListboxSelection)
            self.fileListbox.activate(self.fileListboxSelection)
        if self.fileListboxSelection:
            self.fileListbox.see(self.fileListboxSelection)
        self._printFileData()

    # Method to print file data to dataListbox
    def _printFileData(self):
        self.dataListbox.delete(0, tk.END)
        if self.fileListboxSelection == None:
            self.dataListbox.insert(tk.END, 'No file selected')
            self._clearPreview()
        else:
            self.dataListbox.insert(tk.END, 'Filename: {}'.format(self.files[self.fileListboxSelection].filename))
            self.dataListbox.insert(tk.END, 'Date: {}'.format(self.files[self.fileListboxSelection].creationDate.strftime(dateFormat)))
            self.dataListbox.insert(tk.END, 'Scanner: {}'.format(self.files[self.fileListboxSelection].model))
            if self.files[self.fileListboxSelection].startTVChannel == None:
                startTV = ''
            else:
                startTV = ' (TV{})'.format(self.files[self.fileListboxSelection].startTVChannel)
            self.dataListbox.insert(tk.END, 'Start Frequency: {:.3f}MHz{}'.format(self.files[self.fileListboxSelection].startFrequency, startTV))
            if self.files[self.fileListboxSelection].stopTVChannel == None:
                stopTV = ''
            else:
                stopTV = ' (TV{})'.format(self.files[self.fileListboxSelection].stopTVChannel)
            self.dataListbox.insert(tk.END, 'Stop Frequency: {:.3f}MHz{}'.format(self.files[self.fileListboxSelection].stopFrequency, stopTV))
            self.dataListbox.insert(tk.END, 'Data Points: {}'.format(self.files[self.fileListboxSelection].dataPoints))
            self.dataListbox.insert(tk.END, 'Mean Resolution: {:.3f}MHz'.format(self.files[self.fileListboxSelection].resolution))
            self.dataListbox.insert(tk.END, 'New Filename: {}'.format(self.files[self.fileListboxSelection].newFilename))
            self._updatePreview()
        self._buttonDisable()

    # Method to decide if buttons should be disabled or not
    def _buttonDisable(self):
        if len(self.files) == 0 :
            self._buttonStatus('disabled', 'disabled')
        elif self.fileListboxSelection == None:
            self._buttonStatus('disabled', 'enabled')
        else:
            self._buttonStatus('enabled', 'enabled')

    # Method to print number of files chosen
    def _updateFileStatus(self):
        plural = '' if len(self.files) == 1 else 's'
        if len(self.files) == 0:
            self.fileStatus.configure(foreground='red')
        else:
            self.fileStatus.configure(foreground='black')
        self.numFiles.set('{} file{} added'.format(len(self.files), plural))
 
    # Method to get earliest date from all files or todays date (default)
    def _getScanDate(self):
        if len(self.files) == 0:
            self.scanDateTimestamp = datetime.date.today()
        else:
            self.scanDateTimestamp = min([file.creationDate for file in self.files])
        self.scanDate.set(self.scanDateTimestamp.strftime(dateFormat))
    
    # Method to convert user input directory structure into path
    def parse_structure(self, s):
        for old, new in [('%c', self.country.get()),
                         ('%t', self.town.get()),
                         ('%v', self.venue.get()),
                         ('%y', str(self.scanDateTimestamp.year)),
                         ('%i', self.io.get()),
                         ('%s', self.targetSubdirectory.get()),
                         ('%f', plist['forename']),
                         ('%n', plist['surname']),
                         ('%m', '{:02d}'.format(self.scanDateTimestamp.month)),
                         ('%M', self.scanDateTimestamp.strftime('%B')),
                         ('%d', '{:02d}'.format(self.scanDateTimestamp.day))]:
            s = s.replace(old, new)
        return s
    
    # Method to create master filename
    def _getMasterFilename(self, event=None):
        
        # Return if user has entered a custom master filename
        if self.customMasterFilename:
            return
        
        self.scanMasterFilename.set(self.parse_structure(plist['fileStructure'] + '.csv'))
        if self.defaultOutputLocation.get() == 1:
            self.libraryLocation = plist['defaultLibraryLocation'] + data.slash
            self.targetLocation = self.parse_structure(plist['dirStructure'] + data.slash + '%s').rstrip('/')
        else:
            self.targetLocation = self.targetSubdirectory.get()
            if self.targetSubdirectory.get() != '':
                self.targetLocation = data.slash + self.targetLocation
        self.scanOutputLocation = self.libraryLocation + self.targetLocation
        self.scanOutputLocationDisplay.set(dir_format(self.scanOutputLocation, 90))

        # Set OFCOM Search box when venue edited
        self.ofcomSearch.set('{} {}'.format(self.town.get(), self.venue.get()))
        
    # Method to disable/enable buttons/menu items based on selected files
    def _buttonStatus(self, inputStatus=None, outputStatus=None):
        if inputStatus != None:
            for x in [self.removeFileButton, self.useDateButton]:
                x.config(state=inputStatus)
            if inputStatus == 'enabled':
                inputStatus = 'normal'
            for (menu, item) in [(self.editMenu, 'Remove File'), (self.fileMenu, 'Set Date')]:
                menu.entryconfig(item, state=inputStatus)
                
        if outputStatus != None:
            self.clearFilesButton.config(state=outputStatus)
            if outputStatus == 'enabled':
                self.window.bind_all('<Command-d>', self._useDate)
                self.editMenu.entryconfig('Clear Files', state='normal')
                self.fileMenu.entryconfig('Create File', state='normal')
            else:
                self.window.unbind_all('<Command-d>')
                #self.window.unbind_all('<Command-Return>')
                self.editMenu.entryconfig('Clear Files', state='disabled')
                self.fileMenu.entryconfig('Create File', state='disabled')
     
    # Method to change destination to custom destination    
    def _customDestination(self, event=None):
        customLocation = tkfiledialog.askdirectory(parent=self.masterFrame, title='Select Destination Folder')
        if customLocation != '':
            self.libraryLocation = customLocation
            self.scanOutputLocation = self.libraryLocation
            self.scanOutputLocationDisplay.set(dir_format(self.scanOutputLocation, 90))
            self.defaultOutputLocation.set(0)
            self._updateSubdirectory()
 
    # Method to refresh file data, for use when country or settings change
    def _refresh(self, event=None):
        global dateFormat
        dateFormat = set_date_format()
        for file in self.files:
            file.updateTVChannels(self.country.get())
        self._printFiles()

    # Method to deselect fileListbox
    def _deselectFileListbox(self, event=None):
        self.fileListboxSelection = None
        self.fileListbox.selection_clear(0, tk.END)
        self._selectFileItem()
     
    # Method called after IObox edited
    def _ioBoxEdit(self, event=None):
        self.ioFixed = True
        if not self.customSubdirectory:
            self._updateSubdirectory()
    
    # Method called after subdirectory edited
    def _customSubDirectory(self, event=None):
        self.customSubdirectory = True
        self._getMasterFilename()
    
    # Method to declare user has entered a custom Master Filename    
    def _customMasterFilename(self, event=None):
        self.customMasterFilename = True
        self.defaultMasterFilename.set(0)
    
    # Method to declare user wants to use the standard Filename    
    def _standardMasterFilename(self, event=None):
        self.customMasterFilename = False
        self.defaultMasterFilename.set(1)
        self._getMasterFilename()
            
    # Method to update subdirectory name when standard destination called
    def _updateSubdirectory(self, event=None):
        if self.defaultOutputLocation.get() == 1:
            self.targetSubdirectory.set(self.io.get())
            self.subdirectory = True
        else:
            self.targetSubdirectory.set('')
            self.subdirectory = False
        self._getMasterFilename()

    # Method to update ioBox and Subdirectory when Inside v Outside changes
    def _setIO(self):
        if not self.ioFixed:
            if self.ioGuess >= 0:
                self.ioBox.current(0)
            else:
                self.ioBox.current(1)
            self._updateSubdirectory()

    # Method to open file dialogue and allow selection of files
    def _addFiles(self, event=None, selected_files=None, suppressErrors=False):
        if selected_files == None:
            selected_files = tkfiledialog.askopenfilenames(parent=self.inputFrame, title='Add files', initialdir=plist['defaultSourceLocation'])
        for file in selected_files:
            newFile = File(file, self.country.get())
            if newFile.valid:
                self.ioGuess += newFile.io
                self.files.append(newFile)
                plist['defaultSourceLocation'] = os.path.dirname(file)
            elif not suppressErrors:
                tkmessagebox.showwarning('Invalid File', '{} is not a valid scan file and will not be added to the file list'.format(newFile.filename))
        self._setIO()
        self._printFiles()

    # Method to open file dialogue and allow selection of all files in a directory
    def _addDirectory(self, event=None):
        dirFiles = []
        selectedDir = tkfiledialog.askdirectory(parent=self.inputFrame, title='Add directory', initialdir=plist['defaultSourceLocation'])
        if selectedDir != '':
            plist['defaultSourceLocation'] = selectedDir
            for file in os.listdir(selectedDir):
                fullfilename = '{}{}{}'.format(selectedDir, data.slash, file)
                if not file.startswith('.') and not os.path.isdir(fullfilename):
                    dirFiles.append(fullfilename)
        if len(dirFiles) != 0:
            self._addFiles(None, dirFiles, True)

    # Method to remove file
    def _removeFile(self, event=None):
        if event == None or (event.widget.winfo_class() != 'TEntry' and event.widget.winfo_class() != 'TCombobox'):
            if self.fileListboxSelection == None:
                return
            self.ioGuess -= self.files[self.fileListboxSelection].io
            self._setIO()
            self.files.remove(self.files[self.fileListboxSelection])
            if len(self.files) == 0:
                self.fileListboxSelection = None
            elif self.fileListboxSelection > len(self.files) - 1:
                self.fileListboxSelection = len(self.files) - 1
            self._printFiles(event)
 
    # Method to remove all files
    def _clearFiles(self, event=None, confirmRequired=True):
        self.editMenu.entryconfig('Clear Files', state='disabled')
        if confirmRequired:
            if not tkmessagebox.askyesno('Are you sure?', 'Are you sure you want to clear the file list?'):
                self.editMenu.entryconfig('Clear Files', state='normal')
                return
        del self.files[:]
        self.fileListboxSelection = None
        self.ioFixed = False
        self.ioGuess = 0
        self._printFiles()
         
    # Method to use date from selected file
    def _useDate(self, event=None):
        self.scanDate.set(self.files[self.fileListboxSelection].creationDate.strftime(dateFormat))
        self._getMasterFilename()

    # Method to create master file
    def _createFile(self, event=None):
        if len(self.files) == 0 and not self.includeOfcomData.get():
            tkmessagebox.showinfo('No Files To Create', 'No files to create.')
            return
        
        # Check if user really wants to delete source files
        if self.deleteSourceFiles.get() == 1 and tkmessagebox.askyesno('Are you sure?', 'Are you sure you want to delete the input files?'):
            delSourceConfirmed = True
        else:
            delSourceConfirmed = False

        # Add all files into outputFile list if within limits
        outputFile = []
        filesWritten = 0
        statement = 'The following files were successfully written!\n\nDIRECTORY:\n{}{}\n\n'.format(self.scanOutputLocation, data.slash)
        for file in self.files:
            for freq, value in file.frequencies:
                if freq >= plist['lowFreqLimit'] and (plist['highFreqLimit'] == 0 or freq <= plist['highFreqLimit']):
                    outputFile.append([float(freq), float(value)])
        
        # Remove duplicates
        outputFile = sorted(outputFile)
        i = 1
        while i < len(outputFile):
            if outputFile[i][0] == outputFile[i - 1][0]:
                outputFile.remove(outputFile[i - 1])
            else:
                i += 1

        # Write original files with new filenames
        if self._createDirectory():
            if self.copySourceFiles.get():
                for file in self.files:
                    writtenFilename = self._writeFile(self.scanOutputLocation, file.newFilename, file.frequencies)
                    if not writtenFilename:
                        return False
                    else:
                        filesWritten += 1
                        statement += '{}\n'.format(writtenFilename)
        
            # Write master file
            if len(outputFile) > 0:
                writtenFilename = self._writeFile(self.scanOutputLocation, self.scanMasterFilename.get(), outputFile)
                if not writtenFilename:
                    return False
                else:
                    filesWritten += 1
                    statement += '{}\n'.format(writtenFilename)
            
            # Write OFCOM exclusions files
            if (self.includeOfcomData.get()):
                filename = self._findUnusedFile(self.scanOutputLocation, '{}.cxl'.format(os.path.splitext(self.scanMasterFilename.get())[0]))
                target = self.scanOutputLocation + data.slash + filename
                
                writtenFilename = self._ofcomGenerate(None, self.io.get(), target)
                if writtenFilename:
                    filesWritten += 1
                    statement += '{}\n'.format(filename)
                else:
                    tkmessagebox.showwarning('Timeout', 'Could not connect to the JFMG service, please check your connection.')
                
            statement += '\n{} files written to disk.\n'.format(filesWritten)

            if filesWritten == 0:
                tkmessagebox.showinfo('No Files To Create', 'No files to create.')
                return

            # Write defaults to plist
            plist['defaultVenue'] = self.venue.get()
            plist['defaultTown'] = self.town.get()
            plist['defaultCountry'] = self.country.get()
            plist['defaultCopy'] = self.copySourceFiles.get()
            plist['defaultDelete'] = self.deleteSourceFiles.get()
            plist['defaultOfcomInclude'] = self.includeOfcomData.get()

            with open(plistName, 'wb') as fp:
                plistlib.dump(plist, fp)
         
            if delSourceConfirmed:
                statement += '\nThe following files were deleted:\n'
                for file in self.files:
                    os.remove(file.fullfilename)
                    statement += '{}\n'.format(file.filename)
                self._clearFiles(None, False)
                tkmessagebox.showinfo('Success!', statement)
            else:
                if tkmessagebox.askyesno('Success!', '{}\nWould you like to clear the file list?'.format(statement)):
                    self._clearFiles(None, False)

    def _findUnusedFile(self, directory, filename):
        target = directory + data.slash + filename
        file, ext = os.path.splitext(filename)
        duplicateCounter = 0
        while os.path.isfile(target):
            duplicateCounter += 1
            filename = '{}-{}{}'.format(file, duplicateCounter, ext)
            target = directory + data.slash + filename
        return filename

    # Method to write file to disk
    def _writeFile(self, directory, filename, array):
        filename = self._findUnusedFile(directory, filename)
        target = directory + data.slash + filename
        try:
            with open(target, 'w') as fp:
                for freq, value in array:
                    fp.write('{:09.4f},{:09.4f}\n'.format(freq, value))
            return filename
        except IOError:
            tkmessagebox.showwarning('Fail!', '{} could not be written.'.format(target))
            return False
     
    # Method to create directory structure
    def _createDirectory(self):
        try:
            os.makedirs('{}{}'.format(self.scanOutputLocation, data.slash))
            return True
        except OSError:
            return tkmessagebox.askyesno('Directory already exists', '{}{} already exists. Are you sure?.'.format(self.scanOutputLocation, data.slash))
            
    # Method to remove current preview
    def _clearPreview(self):
    
        # Clear Graph
        self.ax.clear()
        
        # Set Style
        self.ax.set_facecolor('lightGrey')
        self.ax.grid(linestyle='None')
        self.ax.set_axisbelow(True)
        self.ax.set_xticks([])
        self.ax.set_yticks([])
        self.ax.set_xlabel('Frequency /MHz')
        self.ax.set_ylabel('Level /dBm')
        
        # Set Font
        matplotlib.rcParams.update({'font.size': 9 })
        
        # Draw Canvas
        self.canvas.draw()
 
    # Method to draw preview of self.fileListboxSelection
    def _updatePreview(self):
        
        # Get x,y values
        mean = 0
        for x in self.files[self.fileListboxSelection].frequencies:
            try:
                previous
            except:
                previous = [x[0], x[1]]
                xValues = []
                yValues = []
            mean += x[1]
            if previous[0] + (self.files[self.fileListboxSelection].resolution * 2) < x[0]:
                xValues.append(previous[0] + self.files[self.fileListboxSelection].resolution)
                yValues.append(-200)
                xValues.append(x[0] - self.files[self.fileListboxSelection].resolution)
                yValues.append(-200)
            xValues.append(x[0])
            yValues.append(x[1])
            previous = x
        
        # Calculate mean value for potential scaling
        mean /= len(self.files[self.fileListboxSelection].frequencies)
        
        # Get axis values
        ymin = min(i for i in yValues if i > -120)
        ymax = max(yValues)
        ymin = int((ymin - 5) / 5) * 5 if ymin > -95 or ymin < -105 else -105
        ymax = int((ymax + 5) / 5) * 5 if ymax > ymin + 45 else ymin + 45
        xmin = xValues[0]
        xmax = xValues[-1]
        
        # Get x tick values
        minPixelDistance = 25
        axeswidth = self.ax.get_window_extent().transformed(self.fig.dpi_scale_trans.inverted()).width * self.fig.dpi
        minTickDistance = ((xmax - xmin) * minPixelDistance) / axeswidth
        xTicks = []
        prev = 0
        tvCountry = self.country.get() if self.country.get() == 'United States of America' else 'UK'
        for channel in data.TVChannels[tvCountry]:
            if channel[1] - prev >= minTickDistance and self.files[self.fileListboxSelection].frequencies[0][0] <= channel[1] and self.files[self.fileListboxSelection].frequencies[-1][0] >= channel[1]:
                xTicks.append(channel[1])
                prev = channel[1]

        # Clear previous graph
        self.ax.clear()
        
        # Set Style
        self.ax.get_yaxis().set_visible(True)
        self.ax.get_xaxis().set_visible(True)
        self.ax.grid(linestyle='-', color='grey')
        self.ax.fill_between(xValues, int(ymin) - 1, yValues, facecolor='lightGreen')

        # Set axis/ticks
        self.ax.axis([xmin, xmax, ymin, ymax])
        self.ax.set_xticks(xTicks, minor=False)

        # Draw Graph
        self.ax.plot(xValues, yValues, color='green')
        self.canvas.draw()

    # Method to quit application
    def _quit(self, event=None):
        try:
            self.pmseLookup.logout()
        except AttributeError:
            pass
        self.window.quit()
        self.window.destroy()
        sys.exit()

    # Method to display about information
    def _about(self):
        tkmessagebox.showinfo('About', '{} {}\n\n{} Stephen Bunting 2017\nhttp://www.stevebunting.com/'.format(data.title, data.version, chr(169)))

    # Method to open docs in web browser
    def _openHTTP(self):
        browser=webbrowser.get('Safari')
        browser.open('http://rflibrary.stevebunting.com/documentation.php')

    # Method to display settings box
    def _settings(self, event=None):
        global settingsExists, settings
        
        if self.settingsWindowOpen:
            self.settings.bringtofront()
        else:
            self.settingsWindowOpen = True
            self.settings = SettingsWindow()
            self.settings.settingsWindow.mainloop()
            self.settingsWindowOpen = False
            self._refresh()

    # Method to login to OFCOM site
    def _ofcomLogin(self):
        lookup = ofcom.PMSELookup(plist['ofcomAccountName'], plist['ofcomUserName'], keyring.get_password(data.title, plist['ofcomAccountName']))
        
        # Login to OFCOM site
        try:
            lookup.login()
        except requests.exceptions.ConnectionError:
            tkmessagebox.showwarning('Connection Error', 'There was an error connecting to this service, please check your connection.')
            return False
        except ofcom.LoginError:
            if (tkmessagebox.askyesno('Login Fail', 'Could not login to pmse.ofcom.org.uk.\n\nWould you like to check your login details?')):
                self._settings()
            return False
        return lookup

    # Method to search OFCOM database and return a list of possible venues
    def _ofcomSearch(self, event=None):
        try:
            hasattr(self.pmseLookup, 'account_name')
        except AttributeError as e:
            self.pmseLookup = self._ofcomLogin()
            if not self.pmseLookup:
                return
        else:
            if not self.pmseLookup or not self.pmseLookup.loggedin:
                self.pmseLookup = self._ofcomLogin()
                if not self.pmseLookup:
                    return

        # Look up venues
        self.pmseLookupVenues = self.pmseLookup.getList(self.ofcomSearch.get())

        # Venues found
        if len(self.pmseLookupVenues[0]) > 0:
            self.ofcomBox['values'] = self.pmseLookupVenues[0]
            self.ofcomBox.config(state='enabled')

        # No venues found
        else:
            tkmessagebox.showwarning('No venues found', 'No venues found.\n\nTry editing your search term.')
            self.ofcomBox['values'] = self.ofcomVenueList
            self.ofcomBox.config(state='disabled')
        self.ofcomBox.current(0)

    # Method to retrieve data from OFCOM and generate exclusion file
    def _ofcomGenerate(self, event=None, io='Outside', filename=''):
        if len(self.pmseLookupVenues[0]) == 0:
            return False
        else:
            venueID = self.pmseLookupVenues[1][self.ofcomBox.current()]
            
            try:
                data = self.pmseLookup.getData(venueID)
            except requests.exceptions.Timeout:
                return False

            self.pmseLookup.xmlGenerate(data, io, filename)
            return filename


################################################################################
##########                         START GUI                          ##########
################################################################################

if __name__ == '__main__':
    gui = GUI()
    gui.window.mainloop()

